---
layout: post
title: "21. 04. 09 TIL"
date: 2021-04-09
category: read 
excerpt: ""

---

# 21. 04. 09. TIL

> 오늘 한 일  
    1. Instagram Clone LikedList, Comment 구현  
    2. 운영체제 3강 내용 정리

## New Knowledge
---
- Data binding이 뭘까?

    [Data Binding in MVVM on iOS](https://medium.com/flawless-app-stories/data-binding-in-mvvm-on-ios-714eb15e3913)

    MVVM 디자인 패턴을 공부해보면 View Model은 View와 서로 Data binding한다고 되어있다.

    뭔가 데이터를 묶어서 던져준다... 이런 느낌인가 싶은데, 위 포스트를 참고하여 내용 정리를 해보자.

    MVVM의 View와 View Model 사이에는 기본적인 룰이 있는데,

    1. View Model은 View에 의해 소유된다.
    2. View Model은 UI 실행에 필요한 로직과 출력에 대한 입력만 담당한다.
    3. View Model이 UI를 변경하면 안된다.

    위 룰에 따라서, View(View Controller) 또는 View Model에 변경사항이 발생했을 때,

    서로 알려줄 통로(Way)가 필요한데, 그게 Data binding이다.

    즉, Data binding은 UI(View Controller)와 UI에 표시되는 데이터(View Model / Not Model) 사이에 연결을 설정하는 작업이다다.

    그리고, Data binding은 여러가지 방법으로 사용할 수 있고, 여러 가지 디자인 패턴에서 적용될 수 있다.

    우선, 우리는 MVVM에서 적용되는 몇가지 예시를 보자.

    다른 거 보느라 예시를 만들어보지 못했다, 다음에 포스트을 만들어서 연결하자 :)

- UIViewController.navigationController?.pushViewController

    의외였던 부분이 마지막 줄에 view.navigationController?.pushViewController() 인데,  

    LikedListViewController는 NavigationController안에 있지 않아도, 

    기존 뷰가 NavigationController안에 있어서 그런지, 

    view의 navigationController 프로퍼티 내에서 메서드를 실행한다.

```swift
        // Viper Router에서 뷰를 띄우는 메서드 내부
        let likedListVC = UIStoryboard(name: "Main", bundle: nil)
                    .instantiateViewController(identifier: "LikedListVC") as! LikedListViewController
        LikedListRouter.createLikedListModule(view: likedListVC, users: user)
        view.navigationController?.pushViewController(likedListVC, animated: true)
        }
```

    #### **Parameters**

    `viewController`The view controller to push onto the stack. This object cannot be a tab bar controller. **If the view controller is already on the navigation stack, this method throws an exception.**

    공식 문서에 위와 같이 적혀있는데, 강조된 부분을 보면 뷰가 이미 네비게이션 스택 내부에 있을 경우, 예외 처리한다고 되어있다.

    그래서 내부 NavigationController 프로퍼티를 사용하는 듯 하다.

- VIPER Design Pattern

    [iOS 아키텍처 패턴 - VIPER](https://nightohl.tistory.com/entry/iOS-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%ED%8C%A8%ED%84%B4-VIPER)

    VIPER 디자인 패턴은 iOS 아키텍쳐를 구성하는 패턴 중 하나로

    MVC / MVVM과 다르게 5개의 구성요소로 이루어져있다.

    - V(VIew): 다른 디자인 패턴에서와 같은 VIew(View and / or ViewController)
    - I(Interactor): data(Entities) 또는 networking과 관련된 비즈니스 로직을 포함한다.  
        (위 포스트에서 외부 의존성으로 이루어지는 부분은 Services와 Managers를 사용할 것이라 함)

    - P(Presenter): UI관련 비즈니스 로직을 포함하며, Interactor에서 메서드를 호출한다.(중재자 역할)
    - E(Entity): 일반 데이터 객체들을 말한다.(MV(X) 패턴의 모델과 유사한 듯 하다.)
    - R(Router): VIPER 모듈간의 전환(segue)을 담당한다.

    나는 MV(X) 패턴에서 Model은 단순히 데이터 유형을 정의해준다고 생각했는데, 

    위 포스트를 읽어보니, MV(X) 패턴의 Model은 데이터 객체를 담고 데이터 상호작용 로직도 포함했지만, 

    VIPER에선 Interactor와 Entity를 나누면서 로직을 Interactor에, 데이터 객체를 Entity에 구현한다.

    내가 현재 구현하고 있는 Instagram Clone의 Feed가 VIPER로 구현되어 있는데,

    조금 더 이해를 위해 각각 어떤 동작을 하고 있는 지 정리해보려 한다.

    (순서는 뷰에서 부터 시작하겠다.)

    - View
        - 특징: presenter을 프로퍼티로 가진다.
        - 기능: 전반적인 UI와 User Action을 담당하고, 특정 행위가 발생했을 때, Presenter의 메서드를 호출한다.
        - 예시
            - Feed가 로드되면 presenter에 정의된 viewDidLoad()를 호출한다.
            - 프로필 이미지를 탭하면 presenter의 showProfileSelection() 메서드를 호출한다.
    - Presenter
        - 특징: Interactor, View, Wireframe(Router)를 프로퍼티로 가진다.
        - 기능: View에서 호출한 메서드를 바탕으로 각 요소에게 명령을 내리고, Interactor에서 데이터 변경이 일어나면, View에게 알려준다.
        - 예시
            - View에서 viewDidLoad()가 호출되면, Interactor의 getPosts() 메서드를 호출한다.
            - View에서 showProfileSelection이 호출되면, Router의 pushToProfileModule(user: User, view: FeedViewController) 메서드를 호출한다.
            - Interactor에서 postsDidFetch(post: [Post]) 메서드를 호출하면,
    - Router
        - 기능: 모듈 변경(segue)를 담당하고, 일반적으로 Presenter에서 메서드를 호출하면, 화면을 전환(segue)한다.
        - 예시: pushToProfileModule 메서드가 호출되면 메서드에 설정한 화면으로 전환(segue)한다.
    - Interactor
        - 특징: Presenter를 프로퍼티로 가진다.
        - 기능: dataGenerator에서 데이터를 생성해서, 해당 데이터를 전달인자로 Presenter의 postsDidFetch(post: [Post]) 메서드를 실행한다.

            (위 클론 앱은 통신을 통해 데이터를 받아오지 않고, dataGenerator에서 랜덤으로 생성해서 받고 있다.)

    - Entity
        - 특징: Feed에 필요한 데이터 객체인 User, Post, Story를 정의한다.
    
    
## New Exprience
---

- Error: Instance member cannot be used on type X

```swift
    class CommentTableViewCell: UITableViewCell {
    // MARK: IBOutlets
        @IBOutlet weak var profileImageView: UIImageView!

            override class func awakeFromNib() {
            super.awakeFromNib()
            profileImageView.drawCornerRadius(radius: CGSize(
                                                width: profileImageView.bounds.width / 2,
                                                height: profileImageView.bounds.width / 2)
            )
            profileImageView.layer.borderWidth = 0.5
            profileImageView.layer.borderColor = UIColor.systemGray3.cgColor
        }
    }
```

    Error: Instance member 'profileImageView' cannot be used on type 'CommentTableViewCell'

    awakeFromNib을 자동 완성하면 class 가 붙으면서 타입 메서드로 정의된다.

    하지만, profileImageView는 인스턴스 프로퍼티이기 때문에 에러가 발생한다.

    그래서 class를 지워서 인스턴스 메서드로 만들어주면 해결된다.

- 와.... 클론하다가 Gesture Recognizer를 storyboard에서 구현한 레이블에 추가하고,  

    누르면 화면 전환을 하는 걸 구현했는데, Gesture Recognizer에 연결된 메서드가 실행이 안돼서,  

    코드를 하루종일 봐도 안나와서 포기하려다가 Attribute inspector 보니까,  

    User interaction Enabled를 선택해야 상호작용이 되는 거였다....  

    다음부터 스토리보드로 구현된 클론은 하지 말아야겠다.

- Error: "Unable to parse constraint format: \nExpected ']' after specifying thickness. \nV:[lineView(width) \n

    결국 오늘의 마무리는 에러로 하게 되었다.

    LikedList는 구현과 실행까지 완료했지만 Comment View는 구현은 다 됐지만,

    실행이 안된다. 위 에러가 뜨면서 말이다.  

    검색해도 나오지 않는 에러인데, Unable to parse이면 이전 뷰에서 못 넘긴다는 말인가 싶다가도,  

    용어 자체가 parse라서 Comment View 내부의 에러 인 것 같아서 코드를 다 훑었지만  

    찾아내지 못했다. 내일의 시작은 에러 잡는 걸로 해야겠다.

    
## Question
---
- 키보드 높이에 따라 UI를 변경하는 프로퍼티 감시자(willSet)

```swift
    var keyboardHeight = 0 {
        willSet {
            if newValue != 0 {
                textView.transform = CGAffineTransform(
                    translationX: 0,
                    y: -CGFloat(newValue) + textView.bounds.height - 10
                )
                imageView.transform = CGAffineTransform(
                    translationX: 0,
                    y: -CGFloat(newValue) + imageView.bounds.height - 10
                )
                postButton.transform = CGAffineTransform(
                    translationX: 0,
                    y: -CGFloat(newValue) + postButton.bounds.height - 10
                )
            } else {
                textView.transform = .identity
                imageView.transform = .identity
                postButton.transform = .identity
            }
        }
    }
```

- UITableView.automaticDimension

```swift
    // What is automaticDeimension?
    tableView.sectionHeaderHeight = UITableView.automaticDimension
```

- UIView.clipsToBounds

```swift
    // What is clipsToBounds?
    profileView.clipsToBounds = true
```

- String.trimmingCharacter

```swift
    // What is trimmingCharacter?
    let commentContent = textView.text.trimmingCharacters(in: .whitespacesAndNewlines)
```

- tableVIew(_ tableView: UITableView, viewForHeaderInSection section: Int) -> UIView?

```swift
    // viewForHeaderInSection인 걸 봐선,
    // header뷰가 헤더에 출력되지 않을까 싶다.
    func tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -> UIView? {
        headerView.addLine(position: "bottom", color: .systemGray4, width: 0.5)
            
        return headerView
    }
```

- NotificationCenter

```swift
    NotificationCenter.default.addObserver(self,
                                           selector: #selector(keyboardWillShow),
                                           name: UIResponder.keyboardWillShowNotification,
                                           object: nil)
    NotificationCenter.default.addObserver(self,
                                           selector: #selector(keyboardWillShow),
                                           name: UIResponder.keyboardWillHideNotification,
                                           object: nil)
```

- UITextView.textContainer

```swift
    textView.textContainer.lineFragmentPadding = 10
```

```swift
    @objc
    func keyboardWillShow(notification: NSNotification) {
        if let keyboardSize = (notification.userInfo?[UIResponder.keyboardFrameBeginUserInfoKey] as? NSValue)?.cgRectValue {
            let isKeyboardShowing = notification.name == UIResponder.keyboardWillShowNotification
            if let height = UserDefaults.standard.value(forKey: "KeyboardHeight") {
                oneHeight = height as! Int
            } else {
                oneHeight = Int(keyboardSize.height + 25 - view.safeAreaInsets.bottom)
                UserDefaults.standard.set(oneHeight, forKey: "KeyboardHeight")
            }
            keyboardHeight = isKeyboardShowing ? oneHeight : 0
        }
    }
```

- Router Create Module Method

```swift
    // VIPER 패턴에서는 모듈 전환을 할 떄, 타입 메서드로 모듈을 생성해서 이동하는데,
    // 생성할 때 쓰는 메서드는 아래와 같다.
    // 어떤 역할을 하는 지 찾아봐야겠다.
    class CommentRouter: CommentRouterProtocol {
        class func createCommentModule(view: PostDetailViewController, post: Post) {
            let presenter = CommentPresenter()
            presenter.post = post
            view.presenter = presenter
            view.presenter?.wireframe = CommentRouter()
            view.presenter?.view = view
        }
    }
```
