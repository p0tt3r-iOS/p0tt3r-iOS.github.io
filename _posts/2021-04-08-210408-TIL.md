---
layout: post
title: "21. 04. 08 TIL"
date: 2021-04-08
category: read 
excerpt: ""

---

# 21. 04. 08 TIL

> 오늘 한 일  
    1. Instagram Clone Profile 구현  
    2. 프로젝트(Travel Essay) 서버 회원가입 Response 처리하기

## New Knowledge
---
- try? 를 해서 실패를 하면 에러 메세지를 받을 수 없으니,  
    try?를 사용할 때 해결이 안된다면  
    do-catch 블록 안에 try로 넣어서 에러 메세지를 보고 해결해보자.  
    (나의 경우 format이 달라서 decode를 할 수 없다는 메세지를 받고,  
    Int형으로 받던 데이터를 String으로 바꿔서 해결했다.)  

```swift
    do {
        // 회원가입 Response 값을 디코드해서 result에 넣는다.
        let result = try decoder.decode(SignUpResponseModel.self, from: response.data!)
        
        // 회원가입이 실패하면 data가 nil이라, guard로 성공 여부에 따라 분기한다.
        guard data != nil else { return }

        // 본 예시에서는 성공하면 데이터를 출력하는 것으로 했다.
        print(data)
    } catch {
        // 디코드가 실패하면 catch로 받은 에러를 출력한다.
        print(error.localizeddescription)
    }
```

- content inset  
    content offset: ContentView bound 기준 Scroll view의 origin에서 offset되는 지점  
    쉽게 풀어서 설명하면 ContentView를 SuperView라고  
    생각한다음 ScrollView의 frame x, y 값이라고 생각하자.  
    (혹시 bound와 frame에 대한 이해가 없다면 제드님의 블로그를 보고 오자 )  
    [iOS ) Frame과 Bounds의 차이 (1/2)](https://zeddios.tistory.com/203)  
    Content offset이 (0, 0)인 상태에서 ContentView에 inset.top = 100을 주면  
    ScrollView가 ContentView 위로 올라가면서 ContentView의 100pt 위에 위치한다.  
    그렇게 되면, ContentView가 ScrollView의 Top에서    
    100pt 떨어진 위치에서 시작함으로 contentOffset y는 -100이 된다.  
    이해를 돕기 위해 아래 링크의 Figure 1-3, 1-4 이미지를 보자  
    [애플 공식문서 Creating and Configuring Scroll Views](https://developer.apple.com/library/archive/documentation/WindowsViews/Conceptual/UIScrollView_pg/CreatingBasicScrollViews/CreatingBasicScrollViews.html)  
    Content inset은 top, bottom, left, right로 존재하고,  
    Content inset을 줘서 위 아래 빈 칸을 만들 수 있다.  
    Objc에서는 네비게이션바를 넣을 때 오토 레이아웃 적용이 안되었는지,  
    예시를 보면 Inset을 줘서 빈칸을 만들고, 그 위에 네비게이션 바를 올린 듯 하다.  
    그러면 시작 점의 offset은 -x(인셋에 줬던 값)이 될 것이다.  
    드디어 이해했다! 역시 공식문서!  
    (본인도 여기까지 오기 전까지 이해를 못했기 때문에,  텍스트만으로 이해를 요구하는 건  
    무리가 있다고 생각한다.  
    그래서, 위 내용은 추후에 포스트로 써서 연결하려 한다.)  
    테이블뷰 앱으로 돌려봤을 때, 인셋을 주면 확실히 내려온다.  
    하지만 뒤에 컨텐츠 뷰는 없어진 게 아니기 때문에  
    스크롤을 하면 셀들이 빈칸으로 잘 올라간다.  
    그리고 오프셋.y는 -100으로 문제없이 출력된다.  

- UIScrollView.contentInsetAdjustmentBehavior
    - 공식문서: The behavior for determining the adjusted content offsets.  
    - 타입(ContentInsetAdjustmentBehavior): Constants indicating how safe area insets are added to the adjusted content inset.  
    
    adjustedContentInset: Scroll View의 Content insets과 Safe area로 부터 얻은 insets  
    (get타입만 존재: only read)  
    adjustedContentinset = contentInset + system inset  
    그래서 contentinsetAdjustedBehavior로 inset을 주면 content inset은 0이다.  
    content Inset은 우리가 줄 수 있는 값  
    system inset은 contentInsetAdjustBehavior로 결정되는 값  
    contentInsetAdjustmentBehavior: content inset을 조정하는 행동  
    본 프로퍼티는 enum 타입으로 4가지 값을 가질 수 있는데,  
    
    1. automatic: Scrollable할 때, 해당 방향에 대해서 Inset을 준다.  
    2. scrollableAxes: 스크롤 가능한 방향의 Inset을 조정  
        (vertical일 때는 위 아래(top, bottom), horizontal일 때는 좌우(left, right)  
    3. never: Inset을 자동으로 조절하지 않음  
    4. always: 전방향(top, left, right, bottom) Inset을 자동으로 조정  

## New Experience
---
- 코드의 일관성을 가지기가 참 힘든 것 같다.  
    아래의 코드를 보면 3가지 양상을 보이는데,  
    - 첫번째, 전달인자(argument)가 너무 길어서 매개변수 이름(string:)까지 줄을 바꾸는 경우  
    - 두번째, 매개변수가 2개지만, 전달인자가 길어서 다음 줄로 내리는 경우  
    - 세번째, 첫번째 전달인자는 짧지만, 매개변수가 많아서 두번째 매개변수부터 줄을 바꾸는 경우  
    
    각각의 경우가 다르고 길이가 다르다보니, 일관성도 떨어지고 난잡해보인다.  
    이런 경우, 좋은 코더들은 어떻게 일관성을 유지할까?  

```swift
    let postAttributedText = NSMutableAttributedString(
        string: "\(String(describing: user.posts.count))",
        attributes: [NSAttributedString.Key.font : UIFont.boldSystemFont(ofSize: 16)])
    postAttributedText.append(NSAttributedString(
                                string: "\nPost",
                                attributes: [NSAttributedString.Key.font : UIFont.systemFont(ofSize: 14)]))
    postAttributedText.addAttribute(.paragraphStyle,
                                    value: style,
                                    range: NSMakeRange(0, postAttributedText.length))
    postNumButton.setAttributedTitle(postAttributedText, for: .normal)
```
