---
layout: post
title: "21. 04. 20. TIL"
date: 2021-04-20
category: read 
excerpt: ""


---

# 21. 04. 20. TIL

> 오늘 한 일  
    1. 자료구조 / 알고리즘 Chapter 12, 13  
    2. 컴퓨터 네트워크 2강  
    3. 백준 알고리즘 3문제  
    4. iOS Interview 3개 내용 정리  
    5. iOS 스터디 프로젝트(날씨 앱) 뷰 구현  

## New knowledge

---

- 유클리드 호제법  
    - 두 양의 정수 또는 두 다항식의 최대공약수를 구하는 방법 / 인류 최초의 알고리즘  

    - 쉽게 이해하기: 두 자연수 a, b(a > b)가 있을 때, a를 b로 나눈 나머지를 n이라 하면  
        반복을 통해서 n이 0이 되었을 때, b의 값이 최대 공약수이다.

        ```swift
        // gcd는 greatest common divisor(최대 공약수)의 약어
        func gcd(_ a: Int, _ b: Int) -> Int {
        	  let r = a % b
        	  if r != 0 {
        		    return gcd(b, r)
        	  } else {
        		    return b
        	  }
        }
        ```

    - 원리 이해하기(증명)  
        **a = qb + r(나머지 r( 0 ≤ r < b), q는 몫)이라면, gcd(a, b) = gcd(b, r)**  
        (a, b의 최대 공약수 = b, r의 최대 공약수이다.)

        - **gcd(a, b) = G**라고 하면 적당한 서로소인 정수 A,B에 대해 **a = GA, b = GB**가 성립한다.  
            (원래 값(a, b)는 최대공약수 * 특정 값이며, 이 특정 값(A, B)이 서로소가 아니면 최대 공약수가 바뀜)

        - 이를 **a = bq + r**에 대입하면 **GA = GBq + r**이고, 이항하면 **r = G(A - Bq)**이다.  
        
        - **r = G(A - Bq)**와 아까 정의한 **b = G(B)**를 보면 G라는 공통 약수를 가지게 된다.  
        공약수인 것은 위에서 증명을 했으니, 이제 최대공약수가 된다는 것을 증명하면 되는데,  
        위에서 적당한 서로소인 정수를 최대 공약수(G)와 곱하면 최대 공약수가 된다고 했으니,   
        r = G(A-Bq)와 b = G(B)에서 A-Bq와 B가 서로소라는 것을 증명하면 유클리드 호제법이 증명된다.  
  
        이 증명에는 귀류법(어떤 명제를 거짓이라 가정한 후 그 가정이 거짓임을 증명, 반대되는 명제를 참임을 증명하는 방법)이 사용된다.  
  
        - **A - qB = mt, B = nt**  
            두 수가 서로소가 아니라고 가정 했으니, 1보다 큰 최대 공약수(t)가 존재한다.(m, n은 몫)  

        - 이제 B를 첫 번째식에 대입하면, **A - qnt = mt** 가 된다.  
        
        - 조금 변형을 시키면 **A = mt + qnt = t(m + qn)**이 되는데, 여기서 모순이 발생한다.  
        
        - 위에서 A와 B는 서로소라고 정의를 했는데, 위 증명에 따르면 공통 약수(t)를 가진다.  
            **A = t(m + qn) / B = t(n)**  
  
        - 그래서 선택지 2개(서로소이다 / 아니다) 중에 '아니다'가 거짓이라, '서로소이다'가 참으로 증명된다.  

        참고자료  
        [[대수학&정수론]유클리드 호제법의 증명](https://sseong40.tistory.com/3)  

- 최소 공배수 구하는 공식  
    a, b의 최소 공배수를 구할 때는, **a * b / (a, b의 최대 공약수)**  
    **a * b = G * M** 
  
    a 곱하기 b는 최소 공배수 곱하기 최대 공약수기 때문에,   
    이항을 통해 최대 공약수를 구하는 식을 위와 같이 만들 수 있다.
  
- at sign(@) in Swift  
    스위프트 코딩을 하다보면 'at sign' 즉, 골뱅이 사인을 자주 볼 수 있는데,  
    @로 시작하는 키워드들은 컴파일러에게 안내하는 표시이다.  
  
    예를 들어, @IBOutlet을 사용하여 인터페이스 빌더 내의 요소와 연결된 변수를 식별한다.  

- 상태 변화에 따라 다른 동작을 처리하기 위한 앱델리게이트 메서드들을 설명하시오.
    - applicationDidBecomeActive  

        ```swift
        func applicationDidBecomeActive(UIApplication)
        ```  

        델리게이트에게 앱이 inactive 상태에서 active 상태로 전환 되었다고 알립니다.  

        - 사용자 또는 시스템이 앱을 다시 실행시키거나, 사용자가 인터럽션을 무시하면 active 상태로 전환합니다.  
        - 이 메서드가 호출되면, inactive 상태에서 멈춰있던 작업들을 다시 시작시키고 유저 인터페이스를 새로고침합니다.  

    - applicationWillResignActive  

        ```swift
        func applicationWillResignActive(UIApplication)
        ```

        델리게이트에게 앱이 inactive 상태로 전환할 것이라고 알립니다.  

        - 일시적인 인터럽션(전화 또는 메세지)가 발생하거나, 사용자가 앱을 종료해 백그라운드 상태로 전환하기 시작하면 앱은 inactive 상태로 전환합니다.  
        - 이 메서드가 호출되면, 현재 실행을 멈추고 상태를 저장합니다.

    - applicationDidEnterBackground  

        ```swift
        func applicationDidEnterBackground(UIApplication)
        ```

        델리게이트에게 앱이 background에 있다고 알립니다.  

        - 이 메서드가 호출되면, 할당받은 자원을 해제하고, 타이머를 비활성화 하며, 나중에 종료될 것을 대비해 충분한 앱 상태 정보를 저장합니다.  
            또한, 유저 인터페이스를 사용할 수 없고, 연락처 데이터베이스와 같은 일부 유형의 시스템 자원을 사용하지 않습니다.

    - applicationWillEnterForeground  

        ```swift
        func applicationWillEnterForeground(UIApplication)
        ```  

        델리게이트에게 앱이 foreground로 전환할 것이라고 알립니다.  

        - 이 메서드가 호출되면,  백그라운드에 들어갈 때, 적용된 변경사항들을 취소합니다.

    - applicationWillTerminate  

        ```swift
        func applicationWillTerminate(UIApplication)
        ```  

        델리게이트에게 앱이 종료될 것이라고 알립니다.  

        - 이 메서드가 호출되면, 공유 자원 해제, 사용자 데이터 저장, 타이머 비활성화 등 마지막 정리 작업을 실행합니다.  

    - Scene을 사용하면, UIKit은 위 메서드들을 실행하지 않는다.(applicationWillTerminate 제외)  
        대신 sceneDelegate에서 같은 역할을 하는 각각의 메서드를 실행한다.  
  
    - 각 기능을 하는 게 아니라, 로직을 그곳에 구현해야 한다는 말인지 확인해야겠다.

참고자료  
[Apple Developer Documentation: UIApplicationDelegate](https://developer.apple.com/documentation/uikit/uiapplicationdelegate)  

- Scene delegate에 대해 설명하시오.  
    - UISceneDelegate는 scene에서 발생하는 life-cycle 이벤트에 반응 / 관리하기 위한 핵심 메서드들을 가진 프로토콜  

    - SceneDelegate는 UIResponder을 상속하고, UIWindowSceneDelegate를 상속하는 클래스로  
        유저 인터페이스에 대한 Life-cycle을 관리합니다.

    - UIWindowSceneDelegate는 UISceneDelegate를 채택하기 때문에, scene이 앱에 연결되어 있을 때, 상태 전환등이 발생하면 알림을 받습니다.  

    - Scene은 UIWindowScene 클래스의 인스턴스를 말하며, 이 클래스를 사용하여 한 개 또는 여러 개의 윈도우를 관리합니다.(?)  

- 앱이 In-Active 상태가 되는 시나리오를 설명하시오.  
    - 홈 키를 눌러서 홈화면으로 갈 때  
    - 잠금버튼을 눌러서 잠금화면 상태일 때  
    - 앱에서 다른 앱으로 이동할 때  
    - 다른 앱에서 앱화면으로 돌아올 때(Background → Inactive → Active)  
    - 홈 버튼 스왑 또는 이중 클릭을 통해 전환 화면일 때  
    - 전화가 올 때  
    - 문자가 와서 문자를 확대할 때  
    - 스크롤해서 알림센터, 제어센터를 보는 경우

## New experience

---

- 생각의 범위를 늘리는 게 중요한 것 같다.  
    피보나치 수열 알고리즘을 풀었는데, 다른 사람들은 어떻게 풀었나 봤더니 재귀함수, 배열을 이용해서 훨씬 쉽게 해결했다.  
    나는 그저 생각에서 나오는 대로 쓴 다음 예외사항을 추가했는데, 다른 분이 푼 걸 보면 4배 정도 간결하다.  
    많이 배우고 넓게 생각 해야겠다.  

    ```swift
    // 내 코드
    let n = Int(readLine()!)!
        
    var first = 0
    var second = 1
    var temp = 0
        
    if n == 0 {
        print(0)
    } else {
        for _ in 0..<n - 1 {
            temp = first + second
                
            if first > second {
                second = temp
            } else {
                first = temp
            }
        }
        if first > second {
            print(first)
        } else {
            print(second)
        }
    }
    ```

    ```swift
    // 다른 분 코드(코드 길이만 짧은)
    func fivo(_ n: Int) -> Int {
        if n <= 1 {
            return n
        }
        return fivo(n-1) + fivo(n-2)
    }

    print(fivo(Int(readLine()!)!))
    ```

    ```swift
    // 다른 분 코드(코드 길이도 짧고, 시간도 절반)
    let inLine = Int(readLine()!)!
    var fibonacciArr:[Int] = [0,1]
    if inLine > 1 {
        for tempi in 2...inLine {
            fibonacciArr.append(fibonacciArr[tempi-2] + fibonacciArr[tempi-1])
        }
    }
    print(fibonacciArr[inLine])
    ```
