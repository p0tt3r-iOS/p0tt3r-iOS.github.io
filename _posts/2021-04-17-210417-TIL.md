---
layout: post
title: "21. 04. 17. TIL"
date: 2021-04-17
category: read 
excerpt: ""


---

# 21. 04. 17. TIL

> 오늘 한 일  
    1. 개인프로젝트 Core Data 코드 업데이트  
    2. 개인프로젝트 Refactoring  
    3. 자료구조 & 알고리즘 in Swift. Chapter 6, 8 복습 1 / 2  
    4. 21년도 전반기 취업 계획 작성  

## New Knowledge

---

- 문자열 형식 지정자(String Format Specifiers)  
    NSPredicate를 찾아보다가 %@, %& 라는 표현을 봤는데, 
    이는 %d와 같이 문자열 형식을 지정해주는 양식이다.  
    아래 Url을 참조하여 사용할 수 있다.  

    [Apple developer documentation: String Format Specifiers](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFStrings/formatSpecifiers.html#//apple_ref/doc/uid/TP40004265)  

- Create a shadow for UIView

    ```swift
    func addShadow() {
        myView.clipsToBounds = false
        myView.layer.shadowColor = UIColor.black.cgColor
        myView.layer.shadowOpacity = 1
        myView.layer.shadowOffset = .zero
        myView.layer.shadowRadius = 10
        myView.layer.shadowPath = UIBezierPath(roundedRect: gradeImageView.bounds, cornerRadius: backView.frame.height / 10).cgPath
    }
    ```

- 열거형(enum) 타입 사용 빈도가 너무 적다.  
    우선 생각해보면 열거형에 대한 이해가 부족하고, 어디서 사용해야 하는지 모른다.  
    열거형을 복습하고, 사용 빈도를 높혀보자.

- Switch - case 구문도 안쓰니까, 점점 빈도가 줄어든다.  
    문자열에 따라 분기되는 코드는 if - else if 문 보다 switch - case를 사용하자.

- 일반적으로 Core Data에서 context.save() 메서드를 사용하면 요소가 추가되는데,  
    한가지 데이터를 수정하면서 사용하고 싶다면, 매번 update 할 때마다 fetch로 불러서 수정한다.

    ```swift
    // Core Data에 계획을 Update하는 메서드이다.
    func updatePlan() {
        let appDelegate = UIApplication.shared.delegate as! AppDelegate
        let context = appDelegate.persistentContainer.viewContext
        let entity = NSEntityDescription.entity(forEntityName: Constant.shared.planData, in: context)
            
        let fetchRequest = NSFetchRequest<NSFetchRequestResult>(entityName: "PlanData")
           
        do {
            let results = try context.fetch(fetchRequest) as? [NSManagedObject]
            // 불러온 NSManagedObject가 0개가 아니면, 첫번째 요소를의 데이터를 바꾼다.
            // 요소가 2개 이상 추가되지 않게 설정해놓았고, Plan.shared는 계획을 싱글톤으로 구현함
            if results?.count != 0 {
                results?[0].setValue(Plan.shared.choice!.grade, forKey: "grade")
                results?[0].setValue(Plan.shared.day, forKey: "day")
                results?[0].setValue(Plan.shared.isSet, forKey: "isSet")
            } else {
                // 요소가 없는 경우, 일반적으로 NSManagedObject를 생성하고 아래에서 추가한다.
                if let entity = entity {
                    let planData = NSManagedObject(entity: entity, insertInto: context)
                    planData.setValue(Plan.shared.choice!.grade, forKey: "grade")
                    planData.setValue(Int16(Plan.shared.day), forKey: "day")
                    planData.setValue(Plan.shared.isSet, forKey: "isSet")
                }
            }
            // Context에서 얻어(fetch) 온 오브젝트 또는 생성한 오브젝트를 Core Data에 저장한다.
            do {
                try context.save()
            } catch {
                print(error.localizedDescription)
            }
                
        } catch {
            print(error.localizedDescription)
        }
    }
    ```

## Question

---

- 딕셔너리 타입으로 꺼낸 String 타입에 왜 옵셔널이라고 에러가 뜨는지?  

    ```swift
    Plan.shared.choice?.grade = Constant.shared.choice[planData[0].grade!]!
    ```

    아래 코드에서 grade는 non-optional 타입, choice는 [String : String] 타입이다.  
    PlanData.grade는 옵셔널 타입이라, force unwrap(!) 시켜줬는데, 뒤에도 force unwrap 시켜주라고 에러가 발생한다.  
    위 코드와 같이 !를 두번 사용하면 문제 없이 실행되는데, 왜 !가 두 개가 필요할까?
