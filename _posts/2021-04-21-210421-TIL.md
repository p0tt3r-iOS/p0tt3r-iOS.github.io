---
layout: post
title: "21. 04. 21. TIL"
date: 2021-04-21
category: read 
excerpt: ""


---


# 21. 04. 21. TIL

> 오늘 한 일  
    1. 컴퓨터 네트워크 3강  
    2. 백준 알고리즘 3문제  
    3. iOS Interview 3개 내용 정리  
    4. iOS 스터디 프로젝트(날씨 앱) 현재 날씨 뷰 프로토타입 구현

## New knowledge

---

- Swift는 C언어의 array[-1]와 같은 negative index를 지원하지 않는다.  
    그래서 Array의 뒤에서 부터 몇 번째 인덱스를 찾으려면 아래와 같은 코드로 구현하여야 한다.

    ```swift
    let array = [1, 2, 3, 4]
    let index = input.endIndex.advanced(by: -3)
    print(array[index])  // 2

    // advanced(by:) 메서드는 주어진 값(endIndex)에서 일정 거리만큼(-3) 떨어진 값을 반환한다.
    ```

- 소수를 판별하는 알고리즘  

    처음 사용한 방법은 주어진 값을 2...<주어진 값 범위로 반복문 내에서 나누는 방법을 사용했다.  
    하지만, 해당 방법은 무조건 O(n) 시간 복잡도를 가지기 때문에 비효율적이라고 생각해서 찾아보니,  
    소수를 판별하는 가장 효율적인 알고리즘은 주어진 값의 제곱근까지의 값을 확인하는 것이다.  
    (위 방식을 '에라토스테네스의 체'라 부른다.)  

    예를 들어서, 60의 약수는 아래와 같다.  

    ```
    1, 2, 3, 4, 5, 6, 10, 12, 15, 20, 30, 60
    ```

    좌우에 위치한 각 쌍(예를 들어 (1, 60), (2, 30)...)을 곱하면 원래 값을 가지는데,  
    주어진 값(60)의 제곱근은 7.745...이다.  
    
    제곱근은 약수들의 중간에 위치하고, 각 쌍은 제곱근을 기준으로 좌우로 나뉜다.  
    그래서 2부터 제곱근까지의 값을 확인하면 그 이후의 값은 확인할 필요가 없게 된다.  
    (약수는 제곱근이 아닌 경우, 한 쌍으로 존재하고 두 값을 곱하면 원래 값이 나온다.)  
  
    위 방식의 시간 복잡도는 O(√N)이기 때문에, 훨씬 효율적으로 제곱근을 판별하게 된다.  

    ```swift
    func isPrime(_ n: Int) -> Bool {
        for i in 2..<n {
            // 제곱근 함수를 사용하면 아래와 같이 코드를 작성한다.
            // if i >= n.squareRoot()
            // 위 코드와 아래 코드는 동일하게 작동한다.
            if i*i >= n {
                break
            }
            
            if n % i == 0 {
                return false
            }
        }
        
        return true
    }
    ```

    참고자료  
    [소수(Prime Number) 구하기 효율적 알고리즘 :: 코드자몽](https://myjamong.tistory.com/139)

- TableView 또는 CollectionView에 Xib로 만든 Custom Cell을 사용하고 싶다면 Register 해줘야한다.  

    ```swift
    class WeatherViewController: UIViewController {
        @IBOutlet weak var tableView: UITableView!

        override func viewDidLoad() {
            super.viewDidLoad()

            tableView.register(UINib(nibName: "WeatherForTimeTableViewCell", bundle: nil), forCellReuseIdentifier: "WeatherForTimeTableViewCell")
            tableView.dataSource = self
            tableView.delegate = self
        }
    }

    // 아래는 Extension을 통해서 테이블뷰 데이터소스, 델리게이트 메서드를 정의해준다.
    ```

    Xib 파일을 별도로 만들어서 사용할 때, tableView는 Xib 파일이 있는 지 알 수 없으니,  
    등록을 하는 절차가 아닐까 싶다.
  
    확인해보니, 예상과 비슷하다.  
    - 공식문서: Registers a nib object containing a cell with the table view under a specified identifier.  
  
    공식문서에 적힌 내용과 같이 셀을 포함한 nib(Xib) 객체를 특정 Id(identifier)와 함께 등록해준다.

- NSOperationQueue와 GCD Queue의 차이점을 설명하시오.  
    - GCD(Grand Central Dispatch / Dispatch Queue)  
        - low-level C-based API  
        - 사용하기에 가벼움

    - NSOperationQueue
        - high-level Objective-C 클래스  
        - GCD Wrapper(?)  
        - 큐 안의 작업을 취소시킬 수 있다.  
        - KVO를 준수하기 때문에, 프로퍼티를 관찰할 수 있다.  
        - 작업 간의 의존성을 줄 수 있다.  
        - GCD에 비해 무겁고, Boilerplate 코드들이 많이 필요하다.

- GCD API 동작 방식과 필요성에 대해 설명하시오.
    - GCD는 맥OS, iOS, watchOS, tvOS의 멀티 코어 하드웨어에서 동시성 코드 실행을 지원합니다.  
    - BSD 하위 시스템, Core Foundation, Cocoa API는 모두 위 기능을 사용하여, 시스템과 앱이 응답성 향상과 함께 더 빠르고 효율적으로 실행됩니다.  
    - 개별 앱이 다른 코어 수를 가진 각각의 기기에 적응하여 다른 앱들과 Core 자원을 사용하기 위해 경쟁하는 일은 상상만 해도 힘들지만, GCD는 시스템 수준에서 작동하며 균형 잡힌 방식으로 실행중인 모든 응용프로그램의 자원 요구사항을 사용가능한 시스템 자원과 매칭시킨다.  
    - GCD는 DispatchQueue라 부르는 FIFO의 큐를 제공하는데, 블럭(클로저) 단위의 작업들을  해당 큐에 추가합니다.  
    - 작업을 DIspatchQueue에 추가하면 GCD는 스레드 풀의 스레드가 사용 가능할 때, 작업을 스레드에 배치합니다.  
    - 개발 단계에서는 DispatchQueue로 작업을 넘겨주면 GCD가 스레드를 관리하기 때문에, Queue의 동작을 알 필요가 없습니다.  

- 자신만의 Custom View를 만들려면 어떻게 해야하는지 설명하시오.
    - Xib 파일을 통해 커스텀 뷰 생성
        - 쉬운 방법으로는 Cocoa class 파일을 생성하면서 also create Xib file을 선택해서 .swift 파일과 .xib파일을 생성한다.  
        - xib 파일에서 원하는 커스텀 뷰를 구현하고, xib파일과 swift파일을 연결합니다.  
        - 커스텀 뷰를 메인 뷰 컨트롤러에 추가하려면 addSubview() 메서드를 통해 추가할 수 있다.

    - 코드를 통해 커스텀 뷰 생성
        - swift파일을 생성하여 UIView를 상속하는 뷰 클래스를 정의하고,  
        - 해당 클래스에 코드로 원하는 요소를 추가해서 커스텀 뷰를 만들어주고  
        - xib와 같이 addSubview() 메서드로 뷰 컨트롤러에 추가할 수 있다.

    - 만약 뷰 컨트롤러 내부의 뷰를 바꾸고 싶다면, 코드로는 아래와 같이 할 수 있다.

        ```swift
        class ViewController: UIViewController {
        		override func loadView() {
        				view = customView()
        		}
        }
        ```
