---
layout: post
title: "21. 04. 14. TIL"
date: 2021-04-14
category: read 
excerpt: ""


---

# 21. 04. 14. TIL

> 오늘 한 일  
    1. 개인 프로젝트 메인 & 타이머 뷰 구현  
    2. 자료구조 & 알고리즘 in Swift. Chapter 6

## New Knowledge

---

- 클로저로 변수 초기화 하기

    ```swift
    // 처음엔 이렇게 다 만들었는데,
    let days: [Int] = [1, 2, 3, 4, 5, 6, 7,
                    8, 9, 10, 11, 12, 13, 14,
                    15, 16, 17, 18, 19, 20, 21,
                    22, 23, 24, 25, 26, 27, 28]

    // 클로저를 사용하면 보다 편하게 초기화 할 수 있다.
    let days: [Int] = {
        var days: [Int] = []
        for i in 1...28 {
            days.append(i)
        }
            
        return days
    }()
    ```

    사용하면서 성능적인 부분을 고민했는데,   
    솔직히 요즘 하드웨어가 이거 클로저로 돌린다고 성능저하가 될 리 없긴하다...

- 개인 프로젝트를 구현할 때, 1주일 단위로 계획 / 진행상황을 보여주고 싶어서,  
    CollectionViewDataSource에서 cell을 생성할 때, CollectionView의 Width를 7로 나눈 값을  
    cell.widthAnchor.Contraint(equalToContraint:)로 설정했는데,  
    그렇게 하니, Breaking Contraint 에러가 계속 발생했다.  
      
    기존에 시스템에서 자동으로 Constraint를 주는 것 같은데, 계속 찾아봐도 못찾았다.  
    그래서 구글링 하던 중 찾은 방법이 새로 지정한 Constraint에 우선 순위를 지정하는 것이다.  

    ```swift
    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
        let cell = collectionView.dequeueReusableCell(withReuseIdentifier: "IdentifierName", for: indexPath)
        
    		// cellWidth 변수에 컬렉션 뷰 / 7 값을 저장한다.
    		// 1:1 비율을 줄거라 height = width까지 해준다.
        let cellWidth = (collectionView.frame.width) / 7
        let cellHeight = cellWidth
        
    		// 여기서 각 Constraint를 선언하고
        let cellWidthConstraint = cell.widthAnchor.constraint(equalToConstant: cellWidth)
        let cellHeightConstraint = cell.heightAnchor.constraint(equalToConstant: cellHeight)
        
    		// 각 Constraint의 우선순위를 설정한다.
        cellWidthConstraint.priority = .defaultHigh
        cellHeightConstraint.priority = .defaultHigh
        
    		// 여기서 Contraint를 activate 시켜주면, 에러없이 구성된다. :)
        NSLayoutConstraint.activate([
            cellWidthConstraint,
            cellHeightConstraint
        ])

        return cell
    }
    ```

    참고자료: [What is NSLayoutConstraint "UIView-Encapsulated-Layout-Height" and how should I go about forcing it to recalculate cleanly?](https://stackoverflow.com/questions/25059443/what-is-nslayoutconstraint-uiview-encapsulated-layout-height-and-how-should-i)  

- 디바이스에 따라 cell 크기를 변경할 때, if문을 사용하는 것 보다 view(또는 screen)을 나누자.  

    ```swift
    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
        let cell = collectionView.dequeueReusableCell(withReuseIdentifier: PlanCollectionViewCell.identifier, for: indexPath) as! PlanCollectionViewCell
        
        // collectionView에서 inset(108)만 빼고 7로 나누면 자동으로 기기별 적용이 됨
        let cellWidthConstraint = cell.widthAnchor.constraint(equalToConstant: (collectionView.frame.width - 108) / 7)
            
        cellWidthConstraint.priority = .defaultHigh
        cellWidthConstraint.isActive = true
        
        // 이전 코드
        // 4s, SE, 8은 일주일씩 표현이 안돼서 기기별로 셀 크기를 바꿈
        // if collectionView.frame.width < 300 { // 4s
        //     let cellWidth = cell.widthAnchor.constraint(equalToConstant: collectionView.frame.width - 72 / 7)
        // } else if collectionView.frame.width < 350 { // SE, 8
        //     let cellWidth = cell.widthAnchor.constraint(equalToConstant: collectionView.frame.width / 10.5)
        // } else {
        //     let cellWidth = cell.widthAnchor.constraint(equalToConstant: collectionView.frame.width / 10)
        // }

    		return cell
    }
    ```

- UIView 아래에 선 추가하기(add Bottom Border on UIView)

    ```swift
    private func addBottomBorder(view: UIView, width: CGFloat) {
        let border = CALayer()
        border.backgroundColor = UIColor.systemGray4.cgColor
        border.frame = CGRect(x: 0,
                              y: view.frame.size.height - width,
                              width: view.frame.size.width,
                              height: width)
        view.layer.addSublayer(border)
    }
    ```

- defer  
    defer 구문을 사용하면 현재 코드 블럭을 나가기 전 실행 해야할 코드를 작성할 수 있다.  
    오류로 코드 블럭을 나가던, 정상적으로 나가던 defer 구문 내 코드는 실행이 보장된다.  

    ```swift
    let yourAnswer = false

    for i in 0...2 {
        defer {
            print("finished")
        }
    		
        print(i)
    }

    // 0
    // finished
    // 1
    // finished
    // 2
    // finished
    ```

## New Experience

---

- 카운트 다운하는 타이머 구현  
    이전에 Timer 클래스를 사용한 적은 있지만, 
    UI에서 Label로 출력되는 타이머는 처음으로 구현해보았다.  

    ```swift
    class TimerViewController: UIViewController {
        @IBOutlet weak var timerLabel: UILabel!

        var sec = 30
        var timerString = "00:00"
        var timer = Timer()

        @IBAction func startButtonPressed(_ sender: UIButton) {
            timer = Timer.scheduledTimer(timeInterval: 1, target: self, selector: #selector(updateTimerLabel), userInfo: nil, repeats: true)
        }

        @objc func updateTimerLabel() {
            if sec >= 60 {
                timerString = "\(sec / 60):\(sec % 60)"
            } else if sec >= 10 {
                timerString = "00:\(sec)"
            } else {
                timerString = "00:0\(sec)"
            }
            
            timerLabel.text = timerString
            
            if sec == 0 {
                timer.invalidate()
            }
            
            sec -= 1
        }
    }
    ```

    원래 이렇게 구현하는 지는 조금 찾아봐야겠지만, 내 방법도 잘 작동한다. :)

## Question

---

- 블록 내에서 return을 하고, defer 구문 내에서 또 return을 하는 경우  
    자료구조 예제를 확인하던 중 기존 블록에 return하는 값이 있는데,  
     defer 문에서 if를 사용해서 return을 다시 하는 경우가 있었는데,   
    이런 경우, 최초 return 값은 defer문이 실행되는 동안 반환되지 않고  
    defer 문 안에서 교체되는 건지 궁금증이 생겼다.  
      
    실행되는 걸 보면 위에서 이야기한 내용이 맞는데, 원리가 궁금하다.
